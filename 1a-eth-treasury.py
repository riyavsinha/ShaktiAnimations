from manim import *
import os
from custom_objects import *
from flower import FlowerBuddy
from flower_animations import Blink, EyeSmile


class IntroScene(Scene):
    def construct(self):
        flower = FlowerBuddy()
        flower.mouth.smile()
        self.play(FadeIn(flower))
        flower.start_waving()
        self.wait(1)
        self.play(Transform(flower.eyes, flower.eyes.generate_target().eye_smile()), run_time=.75)
        self.wait(1)
        self.play(Transform(flower.eyes, flower.eyes.target.reset()), run_time=.75)
        self.wait(2)
        flower.stop_waving()
        self.wait(1)
        self.play(FadeOut(flower))
        eth = SVGMobject(os.path.join(os.getcwd(), 'assets', 'eth_logo.svg')).shift(UP * 1.75 + LEFT * 4)
        self.wait(1)
        self.play(FadeIn(eth))
        self.wait(1)
        btc = SVGMobject(os.path.join(os.getcwd(), 'assets', 'btc_logo.svg')).shift(UP * 1.75 + RIGHT * 4)
        self.play(FadeIn(btc))
        self.wait(1)
        ada = SVGMobject(os.path.join(os.getcwd(), 'assets', 'ada_logo.svg')).shift(UP * 3).set_color('#1e5cb1')
        self.play(FadeIn(ada))
        self.wait(2)
        # self.play(FadeOut(ada), FadeOut(btc), FadeOut(eth))
        # self.wait(2)
        lock = lock_object().shift(DOWN * 1.5 + LEFT * 2).scale(.75)
        lock_text = Tex(r"Secure").next_to(lock, DOWN, buff=.5)
        web = decentralized_web().shift(DOWN + RIGHT * 2).scale(.75)
        web_text = Tex(r"Decentralized").next_to(web, DOWN, buff=.5)
        self.play(ShowCreation(lock), Write(lock_text))
        self.wait(1)
        self.play(ShowCreation(web), Write(web_text))
        self.wait(4)
        # self.play(FadeOut(lock), FadeOut(lock_text), FadeOut(web_text), FadeOut(web))
        self.play(FadeOut(lock), FadeOut(lock_text), FadeOut(web_text), FadeOut(web), FadeOut(ada), FadeOut(btc),
                  FadeOut(eth))
        iohk = ImageMobject(os.path.join(os.getcwd(), 'assets', 'iohk_logo.png')).shift(UP * 3 + LEFT * 3).scale(2)
        self.play(FadeIn(iohk))
        self.wait(5)
        ada.shift(RIGHT * 3)
        iohk_to_ada = Arrow(iohk.get_right(), ada.get_left(), buff=MED_LARGE_BUFF)
        self.play(FadeIn(ada), ShowCreation(iohk_to_ada))
        self.wait(4)
        p1 = Tex(r"Ethereum Classic Treasury System Proposal").move_to(UP * 1 + LEFT * 2)
        p2 = Tex(r"Ouroboros: A Provably Secure\\Proof-of-Stake Blockchain Protocol").move_to(DOWN * 1.5 + LEFT * 2.5)
        p3 = Tex(r"Impossibility on Tamper-Resilient\\Cryptography with Uniqueness Properties").move_to(
            DOWN * 3 + RIGHT * 1)
        p4 = Tex(r"SoK: A Taxonomy for Layer-2 Scalability\\Related Protocols for Cryptocurrencies").move_to(
            UP * 2.5 + RIGHT * 2)
        p5 = Tex(r"Upper Bound Probability of Double\\Spend Attack on SPECTRE").move_to(DOWN * .5 + RIGHT * 3)
        self.play(FadeIn(p1))
        self.wait(1)
        self.play(FadeIn(p2))
        self.wait(1)
        self.play(FadeIn(p3))
        self.wait(1)
        self.play(FadeIn(p4))
        self.wait(1)
        self.play(FadeIn(p5))
        self.wait(1)
        self.play(FadeOut(iohk), FadeOut(ada), FadeOut(iohk_to_ada), FadeOut(p2), FadeOut(p3), FadeOut(p4), FadeOut(p5))
        self.wait(1)
        self.play(p1.animate.move_to(UP * 3))
        self.wait(1)
        paper_2 = ImageMobject(os.path.join(os.getcwd(), 'assets', 'iohk_paper_2.png')).shift(DOWN / 2)
        self.wait(1)
        self.play(FadeIn(paper_2))
        self.wait(2)
        self.play(FadeOut(p1))
        self.wait(2)
        video_2 = Tex(r"Part 2: game theory, treasury system election proofs").next_to(paper_2, UP, buff=.5)
        video_1 = Tex(r"Part 1: overview, motivations and design decisions").next_to(video_2, UP, buff=.5)
        self.play(Write(video_1))
        self.wait(2)
        self.play(Write(video_2))
        self.wait(3)
        self.clear()
        self.wait(2)


# class EthIntroScene(Scene):
#     def construct(self):
        # Show Basic Block: Tx List
        block_1 = Rectangle(height=3, width=3)
        tx_list = Tex(r"Tx 1\\Tx 2\\ Tx {\textit n}")
        tx_list.next_to(block_1.get_top(), DOWN, buff=0.5)
        self.play(ShowCreation(block_1))
        self.wait(1)
        self.play(Write(tx_list))
        self.wait(1)

        # Show Tx Reward above original list and add miner
        miner = Rectangle(height=1, width=3)
        miner.next_to(block_1, DOWN)
        miner_text = Tex(r"Miner")
        miner_text.move_to(miner);
        self.play(ShowCreation(miner))
        self.play(Write(miner_text))
        self.wait(1)
        tx_reward = Tex(r"Tx Reward")
        tx_reward.set_color(RED)
        self.play(tx_list.animate.shift(.6 * DOWN))
        self.wait(1)
        tx_reward.next_to(tx_list, UP)
        self.play(Write(tx_reward))
        self.wait(1)
        reward_arrow = CurvedArrow(tx_reward.get_right() + .25 * RIGHT, miner.get_right(), angle=-TAU / 4)
        self.play(ShowCreation(reward_arrow))
        self.wait(1)

        # Add Header
        block_1_header = Rectangle(height=1, width=3)
        block_1_header.next_to(block_1, UP, buff=0)
        self.play(ShowCreation(block_1_header))
        block_1_header_text = Tex(r"Prev Hash")
        block_1_header_text.move_to(block_1_header)
        self.play(Write(block_1_header_text))
        self.wait(1)

        # Create new blocks
        block_group = VGroup(block_1, tx_list, tx_reward, block_1_header, block_1_header_text, miner, miner_text,
                             reward_arrow)
        self.play(block_group.animate.shift(LEFT * 4.5))
        self.wait(1)
        block_group_2 = block_group.copy()
        block_group_2.shift(RIGHT * 4.5)
        arrow_1_2 = Arrow(block_group_2[3].get_left(), block_group[3].get_right(), buff=0)
        block_group_3 = block_group_2.copy()
        block_group_3.shift(RIGHT * 4.5)
        arrow_2_3 = Arrow(block_group_3[3].get_left(), block_group_2[3].get_right(), buff=0)
        self.play(TransformFromCopy(block_group, block_group_2))
        self.play(ShowCreation(arrow_1_2))
        self.wait(1)
        self.play(TransformFromCopy(block_group_2, block_group_3))
        self.play(ShowCreation(arrow_2_3))
        self.wait(1)

        # Add the treasury
        blockchain_with_miners = VGroup(block_group, block_group_2, block_group_3, arrow_1_2, arrow_2_3)
        # transformed = blockchain_with_miners.generate_target()
        # transformed.scale(.75)
        # transformed.shift(UP*1.75)
        self.play(Transform(blockchain_with_miners, blockchain_with_miners.generate_target().scale(.75).shift(UP * 2)))
        self.wait(1)
        treasury = Rectangle(height=1, width=3)
        treasury.shift(DOWN * 1.5 + LEFT)
        treasury_text = Tex(r"Treasury")
        treasury_text.move_to(treasury)

        # Arrows from block rewards to treasury
        treasury_arrows = VGroup()
        for block_group in blockchain_with_miners[0:3]:
            treasury_arrow = Arrow(block_group[2].get_right() + .25 * RIGHT, treasury.get_top(), buff=0)
            treasury_arrow.set_color(YELLOW)
            treasury_arrow.set_stroke(width=2, opacity=.75)
            treasury_arrow.get_tip().scale(.75)
            # block_group.add(treasury_arrow)
            treasury_arrows.add(treasury_arrow)

        # Proposals
        proposal_1 = Rectangle(height=1.25, width=4.5)
        proposal_1.next_to(treasury, RIGHT, buff=1.5)
        proposal_1_text = Tex(r"Proposal:\\update protocol")
        proposal_1_text.move_to(proposal_1)
        proposal_1_group = VGroup(proposal_1, proposal_1_text)
        arrow_proposal_1 = Arrow(treasury.get_right(), proposal_1.get_left(), buff=0)
        # self.play(ShowCreation(arrow_proposal_1))
        self.play(ShowCreation(proposal_1))
        self.play(Write(proposal_1_text))
        self.wait(1)

        proposal_2 = Rectangle(height=1.25, width=4.5)
        proposal_2.next_to(proposal_1, DOWN)
        proposal_2_text = Tex(r"Proposal:\\fix wallet bug")
        proposal_2_text.move_to(proposal_2)
        proposal_2_group = VGroup(proposal_2, proposal_2_text)
        arrow_proposal_2 = Arrow(treasury.get_right(), proposal_2.get_left(), buff=0)
        # self.play(ShowCreation(arrow_proposal_2))
        self.play(ShowCreation(proposal_2))
        self.play(Write(proposal_2_text))
        self.wait(3)

        diagram_with_proposals = VGroup(blockchain_with_miners, proposal_2_group, proposal_1_group)
        self.play(FadeOut(diagram_with_proposals))
        q1 = Tex(r"1) Who funds the proposals?").shift(UP * 3)
        q2 = Tex(r"2) Who decides which proposals get funded?").next_to(q1, DOWN)
        q3 = Tex(r"3) How are winning proposals decided?").next_to(q2, DOWN)
        q4 = Tex(r"4) How are funds reliably transferred to the winners?").next_to(q3, DOWN)
        q1.align_to(q4, LEFT)
        q2.align_to(q4, LEFT)
        q3.align_to(q4, LEFT)
        self.play(Write(q1))
        self.wait(2)
        self.play(Write(q2))
        self.wait(2)
        self.play(Write(q3))
        self.wait(2)
        self.play(Write(q4))
        self.wait(2)
        self.play(FadeOut(q2), FadeOut(q3), FadeOut(q4))
        self.wait(2)
        self.play(FadeOut(q1))
        self.wait(2)
        self.play(FadeIn(diagram_with_proposals))
        self.wait(1)

        # Central Authority
        govt = Rectangle(height=1, width=3)
        govt.move_to(treasury)
        govt_text = Tex(r"Government")
        govt_text.move_to(govt)
        govt_arrow_1 = Arrow(govt.get_right(), proposal_1.get_left(), buff=0)
        govt_arrow_2 = Arrow(govt.get_right(), proposal_2.get_left(), buff=0)
        self.play(ShowCreation(govt), Write(govt_text), ShowCreation(govt_arrow_1), ShowCreation(govt_arrow_2))
        self.wait(3)
        govt_group = VGroup(govt, govt_text, govt_arrow_1, govt_arrow_2)
        self.play(FadeOut(govt_group))
        self.wait(3)

        # Community Funding
        comm = Rectangle(height=2, width=3)
        comm.move_to(treasury)
        comm_text = Tex(r"Community Funding")
        comm_text.scale(.75)
        comm_text.next_to(comm.get_bottom(), DOWN, buff=.1)
        comm_people = VGroup(Circle(radius=.3), Circle(radius=.3), Circle(radius=.3)).arrange()
        comm_people.move_to(comm)
        comm_arrow_1 = Arrow(comm.get_right(), proposal_1.get_left(), buff=0)
        comm_arrow_2 = Arrow(comm.get_right(), proposal_2.get_left(), buff=0)
        self.play(ShowCreation(comm_people))
        self.play(ShowCreation(comm), Write(comm_text), ShowCreation(comm_arrow_1), ShowCreation(comm_arrow_2))
        self.wait(3)
        comm_group = VGroup(comm, comm_text, comm_arrow_1, comm_arrow_2, comm_people)
        self.play(FadeOut(comm_group))
        self.wait(3)

        self.play(ShowCreation(treasury))
        self.play(Write(treasury_text))
        self.wait(2)
        self.play(ShowCreation(treasury_arrows))
        self.wait(2)
        treasury_group = VGroup(treasury, treasury_arrows, treasury_text)
        self.play(FadeOut(treasury_group))
        self.play(FadeIn(treasury_group))
        self.play(FadeOut(treasury_group))
        self.play(FadeIn(treasury_group))
        self.play(FadeOut(treasury_group))
        self.play(FadeIn(treasury_group))
        self.wait(2)
        treasury_proposal_1_arrow = Arrow(treasury.get_right(), proposal_1.get_left())
        treasury_proposal_2_arrow = Arrow(treasury.get_right(), proposal_2.get_left())
        self.play(ShowCreation(treasury_proposal_1_arrow), ShowCreation(treasury_proposal_2_arrow))
        self.wait(1)
        self.play(Uncreate(treasury_proposal_1_arrow), Uncreate(treasury_proposal_2_arrow))
        self.wait(2)
        self.clear()


# class StakeholdersScene(Scene):
#     def construct(self):
        q1 = Tex(r"1) Who funds the proposals?").shift(UP * 3)
        q2 = Tex(r"2) Who decides which proposals get funded?").next_to(q1, DOWN)
        q3 = Tex(r"3) How are winning proposals decided?").next_to(q2, DOWN)
        q4 = Tex(r"4) How are funds reliably transferred to the winners?").next_to(q3, DOWN)
        q1.align_to(q4, LEFT)
        q2.align_to(q4, LEFT)
        q3.align_to(q4, LEFT)
        self.play(Write(q1), Write(q2), Write(q3), Write(q4))
        self.wait(2)
        self.play(FadeOut(q1))
        self.wait(2)
        self.play(FadeOut(q4))
        self.wait(2)
        self.play(FadeOut(q2), FadeOut(q3))
        self.wait(2)
        flower = FlowerBuddy()
        flower.mouth.smile()
        self.play(FadeIn(flower))
        self.wait(1)
        self.play(Blink(flower))
        self.wait(1)
        etcd = etc_dollar().shift(UP * 2)
        self.play(FadeIn(etcd), flower.eyes.animate.look_at(etcd))
        self.wait(2)
        equal = Tex(r'\textbf{=}', color='WHITE').shift(UP * 2)
        self.play(Transform(etcd, etcd.generate_target().next_to(equal, LEFT)), Blink(flower))
        dol = dollar().next_to(equal, RIGHT)
        var = Tex(r'1000').next_to(etcd, LEFT)
        var2 = Tex(r'1000').next_to(etcd, LEFT)
        self.play(FadeIn(dol), FadeIn(var), FadeIn(equal))
        self.wait(1)
        var_down = Tex(r'500', color='RED').next_to(etcd, LEFT)
        self.play(Transform(var, var_down), flower.mouth.animate.o_mouth())
        self.wait(2)
        var_up = Tex(r'1500', color='GREEN').next_to(etcd, LEFT)
        self.play(Transform(var, var2), flower.mouth.animate.smile())
        self.play(Transform(var, var_up))
        flower2 = FlowerBuddy('#b547d0', '#ca94f2').next_to(flower, LEFT)
        flower2.mouth.smile()
        flower3 = FlowerBuddy('#e49928', '#f0c788').next_to(flower, RIGHT)
        flower3.mouth.smile()
        flower4 = FlowerBuddy('#e49928', '#f0c788').next_to(flower2, LEFT)
        flower4.mouth.smile()
        flower5 = FlowerBuddy().next_to(flower3, RIGHT)
        flower5.mouth.smile()
        self.wait(2)
        self.play(FadeOut(var), FadeOut(equal), FadeOut(dol), Transform(etcd, etcd.generate_target().move_to(UP * 2)))
        self.wait(1)
        self.play(FadeIn(flower2), FadeIn(flower3), flower.eyes.animate.reset())
        self.wait(1)
        self.play(FadeIn(flower4), FadeIn(flower5), Blink(flower2))
        self.wait(1)
        self.play(Blink(flower5), Blink(flower))
        self.wait(2)
        self.clear()


# class FundingEpochScene(Scene):
#     def construct(self):
        blockchain_unepoched = VGroup()
        for i in range(8):
            b = Rectangle(WHITE, .8, 1.2)
            blockchain_unepoched.add(b)
        blockchain_unepoched.arrange()
        for i in range(7):
            blockchain_unepoched.add(Line(blockchain_unepoched[i].get_right(), blockchain_unepoched[i + 1].get_left()))
        blockchain_unepoched.shift(UP * 2)
        self.play(ShowCreation(blockchain_unepoched))
        self.wait(2)
        epoch_brace = Brace(VGroup(blockchain_unepoched[2:6]))
        epoch_brace_text = epoch_brace.get_text("Funding Epoch")
        self.play(FadeIn(epoch_brace), Write(epoch_brace_text))
        self.wait(3)
        epoch_brace_long = Brace(VGroup(blockchain_unepoched[1:7]))
        self.play(Transform(epoch_brace, epoch_brace_long))
        self.wait(3)
        epoch_brace_short = Brace(VGroup(blockchain_unepoched[3:5]))
        self.play(Transform(epoch_brace, epoch_brace_short))
        self.wait(3)
        self.play(FadeOut(epoch_brace), FadeOut(epoch_brace_text))
        self.wait(1)

        blockchain = VGroup()
        for i in range(2):
            b1 = Rectangle(WHITE, .8, 1.2)
            b2 = Rectangle(WHITE, .8, 1.2)
            bdot = Rectangle(BLACK, .8, .6)
            b3 = Rectangle(WHITE, .8, 1.2)
            blocks = VGroup(b1, b2, bdot, b3).arrange()
            b1_text = Tex(r'1').move_to(b1).scale(.75)
            b2_text = Tex(r'2').move_to(b2).scale(.75)
            b3_text = Tex(r'185142').move_to(b3).scale(.7)
            dots = Tex(r'...').move_to(bdot)
            arr12 = Line(b1.get_right(), b2.get_left())
            arr2dot = Line(b2.get_right(), bdot.get_left())
            arrdot3 = Line(bdot.get_right(), b3.get_left())
            epoch = VGroup(blocks, VGroup(arr12, arr2dot, arrdot3), dots, VGroup(b1_text, b2_text, b3_text))
            blockchain.add(epoch)
        blockchain.arrange()
        l1 = Line(blockchain[0].get_right(), blockchain[1].get_left())
        l_left = Line(blockchain[0].get_left(), blockchain[0].get_left() + LEFT * .5)
        l_right = Line(blockchain[1].get_right(), blockchain[1].get_right() + RIGHT * .5)
        blockchain.add(l1, l_left, l_right)
        blockchain.shift(UP * 2)
        self.play(Transform(blockchain_unepoched, blockchain[1], run_time=2))
        self.wait(2)
        brace1 = Brace(blockchain[1], UP)
        brace1_text = brace1.get_tex(r'\text{Epoch i}')
        self.play(FadeIn(brace1), Write(brace1_text))
        self.wait(2)
        self.play(FadeIn(blockchain[0]), FadeIn(blockchain[2:]))
        self.wait(1)
        brace2 = Brace(blockchain[0], UP)
        brace2_text = brace2.get_tex(r'\text{Epoch i-1}')
        self.play(FadeIn(brace2), Write(brace2_text))
        self.wait(2)
        sub_brace = Brace(VGroup(blockchain[0], blockchain[3]))
        sub_brace_text = sub_brace.get_tex(r'Submission')
        self.play(FadeIn(sub_brace), FadeIn(sub_brace_text))
        self.wait(2)
        dot_center = Point(blockchain[1][0][2].get_center())
        vote_brace = Brace(Group(blockchain[1][0][0], dot_center))
        vote_brace_text = vote_brace.get_tex(r'Voting')
        self.play(FadeIn(vote_brace), FadeIn(vote_brace_text))
        self.wait(2)
        final_brace = Brace(Group(dot_center, blockchain[1][0][3]))
        final_brace_text = final_brace.get_tex(r'Finalization')
        self.play(FadeIn(final_brace), FadeIn(final_brace_text))
        self.wait(2)
        self.play(FadeOut(vote_brace), FadeOut(vote_brace_text), FadeOut(final_brace), FadeOut(final_brace_text))
        self.wait(2)
        self.play(FadeOut(sub_brace), FadeOut(sub_brace_text))
        self.wait(2)
        prop_1_i_tip = blockchain[0][0][0].get_bottom()
        prop_1_i = Arrow(prop_1_i_tip + 2*DOWN, prop_1_i_tip)
        prop_1_i_text = MathTex(r'p_1^{(i)}').next_to(prop_1_i, DOWN)
        self.play(ShowCreation(prop_1_i), Write(prop_1_i_text))
        self.wait(2)
        prop_2_i_tip = blockchain[0][0][2].get_bottom()
        prop_2_i = Arrow(prop_2_i_tip + 2*DOWN, prop_2_i_tip)
        prop_2_i_text = MathTex(r'p_2^{(i)}').next_to(prop_2_i, DOWN)
        self.play(ShowCreation(prop_2_i), Write(prop_2_i_text))
        self.wait(2)
        prop_3_i_tip = blockchain[0][0][3].get_bottom()
        prop_3_i = Arrow(prop_3_i_tip + 2*DOWN, prop_3_i_tip)
        prop_3_i_text = MathTex(r'p_1^{(i+2)}').next_to(prop_3_i, DOWN)
        self.play(ShowCreation(prop_3_i), Write(prop_3_i_text))
        self.wait(2)
        prop_field_1 = Tex('1) Name')
        prop_field_2 = Tex('2) Description URL')
        prop_field_3 = Tex('3) URL Content Hash')
        prop_field_4 = Tex('4) Payment Address')
        prop_field_5 = Tex('5) Payment Amount')
        prop_field_6 = Tex('6) Collateral Transaction')
        prop_field_7 = Tex('7) Start Block')
        prop_field_8 = Tex('8) End Block')
        prop_fields = VGroup(prop_field_1, prop_field_2, prop_field_3, prop_field_4, prop_field_5, prop_field_6, prop_field_7, prop_field_8)
        prop_fields.arrange(DOWN).scale(.6).next_to(blockchain[1], DOWN).shift(DOWN*1.5)
        for field in prop_fields:
            self.play(Write(field.align_to(prop_field_6, LEFT)))
        self.wait(2)
        prop_pay_tip = blockchain[1][0][3].get_bottom()
        prop_pay = Arrow(prop_pay_tip + 1.5*DOWN, prop_pay_tip, color=YELLOW)
        prop_pay_text = MathTex(r'B^{(i)} Payment', color=YELLOW).next_to(prop_pay, DOWN)
        self.play(ShowCreation(prop_pay), Write(prop_pay_text))
        self.wait(2)
        self.play(FadeOut(prop_fields))
        self.play(FadeOut(prop_pay), FadeOut(prop_pay_text), FadeOut(prop_3_i_text), FadeOut(prop_3_i),
                  FadeOut(prop_2_i), FadeOut(prop_2_i_text), FadeOut(prop_1_i), FadeOut(prop_1_i_text))
        self.wait(2)
        self.play(FadeIn(vote_brace), FadeIn(vote_brace_text))
        self.wait(2)
        self.play(FadeOut(vote_brace), FadeOut(vote_brace_text))
        flower = FlowerBuddy().shift(DOWN + LEFT * 2)
        flower.mouth.smile()
        self.play(FadeIn(flower))
        ballot_paper = Rectangle(WHITE, 1.5, 1.1)
        ballot_text = MathTex(r'vb_{v_1}^{(i)}').move_to(ballot_paper)
        ballot = VGroup(ballot_text, ballot_paper).shift(DOWN)
        self.play(FadeIn(ballot))
        hash_box = Rectangle(WHITE, 1.5, 1.5)
        hash_text = Tex(r'Hash\\FN').move_to(hash_box)
        hash_fn = VGroup(hash_text, hash_box).shift(DOWN + RIGHT * 2)
        self.play(FadeIn(hash_fn))
        self.wait(2)
        commitment_paper = Rectangle(WHITE, 1.5, 1)
        commitment_text = MathTex(r'c_{v_1}^{(i)}').move_to(commitment_paper)
        commitment = VGroup(commitment_text, commitment_paper).shift(DOWN)
        commitment.move_to(hash_fn).shift(RIGHT * 2)
        self.play(FadeOutAndShift(ballot, RIGHT))
        self.play(FadeInFrom(commitment, LEFT))
        self.wait(1)
        commitment_arrow = Arrow(commitment.get_top() + UP * .1, blockchain[1][0][1].get_bottom() + DOWN * .1)
        self.play(ShowCreation(commitment_arrow))
        self.wait(2)
        self.play(Uncreate(commitment_arrow))
        self.wait(2)
        garble_box = Rectangle(WHITE, 1.5, 1.5)
        garble_text = Tex(r'???').move_to(garble_box)
        garble = VGroup(garble_text, garble_box).shift(DOWN)
        self.play(FadeOutAndShift(commitment, LEFT))
        self.play(FadeInFrom(garble, RIGHT))
        self.wait(1)
        self.play(FadeOut(garble))
        self.wait(2)
        self.play(FadeIn(final_brace), FadeIn(final_brace_text))
        self.wait(2)
        self.play(FadeOut(final_brace), FadeOut(final_brace_text))
        self.wait(2)
        self.play(FadeIn(ballot))
        self.wait(1)
        ballot_arrow = Arrow(ballot.get_top() + UP * .1, blockchain[1][0][2].get_bottom() + RIGHT * .5 + DOWN * .1)
        self.play(ShowCreation(ballot_arrow))
        self.wait(2)
        self.clear()
        self.wait(2)


# class VoterScene(Scene):
#     def construct(self):
        flower = FlowerBuddy().shift(DOWN * 1.5)
        flower.mouth.smile()
        flower2 = FlowerBuddy().shift(DOWN * 1.5)
        flower2.mouth.smile()
        self.play(FadeIn(flower))
        self.wait(1)
        dol = etc_dollar().next_to(flower)
        self.play(FadeIn(dol), flower.eyes.animate.look_at(dol))
        c1 = Tex(r'1) No direct incentive to vote')
        c2 = Tex(r'2) No locked stake').align_to(c1, LEFT)
        c3 = Tex(r'3) Potential network burden').align_to(c1, LEFT)
        concerns = VGroup(c1, c2, c3).arrange(DOWN).shift(UP*2)
        self.play(Write(c1))
        self.wait(1)
        self.play(Write(c2))
        self.wait(1)
        self.play(Write(c3))
        self.wait(1)
        self.play(FadeOut(concerns), FadeOut(dol), Transform(flower, flower2))
        self.remove(flower2)
        self.wait(1)
        heights = [4, 10, 9, 12, 15, 7, 14, 19, 20, 12]
        xs = [-5, -2, 4, 0, -4, 2, 5, -2, 3, 0]
        props = []
        for i in range(10):
            paper = Rectangle('#c0c0c0', 2.5, 1.5, fill_color='#c0c0c0', stroke_opacity=.8, fill_opacity=.8).shift(
                RIGHT * xs[i] + UP * heights[i])
            paper_text = Tex(r'PROPOSAL', color=BLACK).move_to(paper).scale(.5)
            prop = VGroup(paper, paper_text)
            props.append(prop)
        self.play(*[Transform(prop, prop.generate_target().shift(DOWN * 30), run_time=9, rate_func=linear) for prop in
                    props], flower.mouth.animate.o_mouth(), flower.eyes.animate.look(UP))
        self.wait(1)
        self.play(flower.mouth.animate.smile())
        treasury = Rectangle(WHITE, 1, 5).shift(UP*3)
        treasury_text = Text(r'Treasury').move_to(treasury)
        treasury_group = VGroup(treasury, treasury_text)
        self.play(FadeIn(treasury_group), flower.eyes.animate.look(UP))
        self.wait(1)
        vtreasury = Rectangle(BLUE, 1, 1, fill_color=BLUE, fill_opacity=1).move_to(treasury).align_to(treasury, RIGHT)
        ptreasury = Rectangle(GREEN, 1, 4, fill_color=GREEN, fill_opacity=1).move_to(treasury).align_to(treasury, LEFT)
        self.play(FadeIn(ptreasury))
        self.wait(1)
        self.play(ptreasury.animate.shift(DOWN*2 + LEFT*3), flower.eyes.animate.look_at(UP+LEFT))
        ptreasury_text = Text(r'Proposal Fund').next_to(ptreasury, DOWN).scale(.5)
        ptreasury_line = Line(ptreasury.get_top(), treasury.get_bottom())
        self.play(ShowCreation(ptreasury_line), Write(ptreasury_text))
        self.wait(1)
        self.play(FadeIn(vtreasury), flower.eyes.animate.look(UP))
        self.wait(1)
        self.play(vtreasury.animate.shift(DOWN*2 + RIGHT*1.5), flower.eyes.animate.look_at(UP+RIGHT))
        vtreasury_text = Text(r'Voter Fund').next_to(vtreasury, DOWN).scale(.5)
        vtreasury_line = Line(vtreasury.get_top(), treasury.get_bottom())
        self.play(ShowCreation(vtreasury_line), Write(vtreasury_text))
        self.wait(2)
        self.play(FadeOut(vtreasury_line), FadeOut(vtreasury_text), FadeOut(vtreasury),
                  FadeOut(ptreasury_line), FadeOut(ptreasury_text), FadeOut(ptreasury),
                  FadeOut(treasury_group))

        self.wait(2)
        self.play(flower.animate.shift(LEFT))
        money_row = VGroup(etc_dollar(), etc_dollar(), etc_dollar(), etc_dollar()).arrange()
        money_row2 = VGroup(etc_dollar(), etc_dollar(), etc_dollar(), etc_dollar()).arrange()
        money = VGroup(money_row, money_row2).arrange(DOWN).scale(.7).next_to(flower)
        self.play(FadeIn(money), flower.eyes.animate.look(RIGHT))
        self.wait(2)
        self.play(Transform(money_row[0], money_row[0].generate_target().set_opacity(.2)))
        self.wait(2)
        flower3 = FlowerBuddy('#b547d0', '#ca94f2').next_to(flower, UP)
        flower3.mouth.smile()
        flower3copy = flower3.copy()
        flower3.eyes.look(RIGHT)
        money_row_3 = VGroup(etc_dollar(), etc_dollar(), etc_dollar()).arrange().scale(.7).next_to(flower3)
        self.play(FadeIn(flower3), FadeIn(money_row_3))
        self.wait(2)
        self.play(Transform(money_row_3, money_row_3.generate_target().set_opacity(.2)))
        vote1_copy = money_row[0].copy().set_color(PINK).set_opacity(.8)
        vote3_copy = money_row_3.copy().set_color(PURPLE).set_opacity(.8)
        self.play(Transform(vote1_copy, vote1_copy.generate_target().shift(LEFT * 4)),
                  flower.eyes.animate.look(LEFT), flower3.eyes.animate.look(DOWN + LEFT))
        self.wait(1)
        self.play(Transform(vote3_copy, vote3_copy.generate_target().shift(LEFT * 7)),
                  flower.eyes.animate.look(LEFT + UP), flower3.eyes.animate.look(LEFT))
        self.wait(2)
        self.play(FadeOut(vote1_copy), FadeOut(vote3_copy), FadeOut(money), FadeOut(money_row_3))
        self.wait(2)
        flowers = VGroup(flower, flower3)
        self.play(Transform(flowers, flowers.generate_target().arrange().shift(DOWN)))
        flowerCopy = FlowerBuddy().move_to(flower)
        flowerCopy.mouth.smile()
        flower3Copy = FlowerBuddy('#b547d0', '#ca94f2').move_to(flower3)
        flower3Copy.mouth.smile()
        self.play(Transform(flower, flowerCopy), Transform(flower3, flower3Copy))
        vtreasury = Rectangle(BLUE, 2, 2, fill_color=BLUE, fill_opacity=1).move_to(UP * 2)
        vtreasury_text = Text(r'Voter Fund').next_to(vtreasury, UP).scale(.5)
        self.play(FadeIn(vtreasury), Write(vtreasury_text))
        self.wait(2)
        v1fund = Rectangle(PINK, 2, .5, fill_opacity=1, stroke_color=BLACK).move_to(vtreasury).align_to(vtreasury, LEFT)
        v2fund = Rectangle('#b547d0', 2, 1.5, fill_opacity=1, stroke_color=BLACK).move_to(vtreasury).align_to(vtreasury,
                                                                                                              RIGHT)
        self.play(FadeIn(v1fund))
        self.wait(1)
        self.play(FadeIn(v2fund))
        self.wait(1)
        orig_funds = VGroup(v1fund, v2fund)
        orig_copy = orig_funds.copy()
        small_funds = VGroup(*[Rectangle(ORANGE, 2, .2, stroke_color=BLACK, fill_opacity=1, stroke_width=1.5) for x in
                               range(10)]).arrange(buff=0).move_to(vtreasury)
        self.play(Transform(orig_funds, small_funds))
        self.wait(2)
        med_funds = VGroup(*[Rectangle(ORANGE, 2, 2 / 6, stroke_color=BLACK, fill_opacity=1, stroke_width=1.5) for x in
                             range(6)]).arrange(buff=0).move_to(vtreasury)
        self.play(Transform(orig_funds, med_funds))
        large_funds = VGroup(
            *[Rectangle(ORANGE, 2, 2 / 4, stroke_color=BLACK, fill_opacity=1, stroke_width=1.5) for x in
              range(4)]).arrange(buff=0).move_to(vtreasury)
        self.wait(2)
        self.play(Transform(orig_funds, large_funds))
        self.wait(2)
        self.play(Transform(orig_funds, med_funds))
        self.wait(2)
        self.play(ReplacementTransform(orig_funds, orig_copy))
        self.wait(2)
        pink_half = Rectangle(PINK, 1, .5, fill_opacity=1, stroke_color=BLACK).move_to(v1fund).align_to(v1fund, DOWN)
        purple_part = Rectangle('#b547d0', 1.5, 1.5, fill_opacity=1, stroke_color=BLACK).move_to(v2fund).align_to(
            v2fund, DOWN)
        self.play(Transform(orig_copy[0], pink_half))
        self.wait(1)
        self.play(Transform(orig_copy[1], purple_part))
        self.wait(2)
        self.clear()


# class VotingScene(Scene):
#     def construct(self):
        rule_title = Tex(r'Election Rule').move_to(UP * 3)
        rule_func = MathTex(r'f(P^{(i)}, V^{(i)}, VB^{(i)}) \rightarrow \{p_{\varpi(1)}^{(i)} \dots p_{\varpi(k)}^{(i)}\}').next_to(
            rule_title, DOWN, buff=.5)
        rules = VGroup(rule_title, rule_func)
        self.play(Write(rule_title))
        self.wait(2)
        self.play(Write(rule_func))
        self.wait(2)
        self.play(FadeOut(rules))
        paper = Rectangle(WHITE, 7, 8, fill_color=BLACK, fill_opacity=1)
        proposals = VGroup(Tex(r'Prop.'), Tex(r'A'), Tex(r'B'), Tex(r'C'), Tex(r'D'), Tex(r'E')) \
            .arrange(DOWN, buff=MED_LARGE_BUFF)
        map(lambda prop: prop.align_to(proposals[0], LEFT), proposals[1:])
        proposals.move_to(paper).align_to(paper, LEFT).shift(DOWN * .4 + RIGHT * .3)
        ballot_title = Tex(r'B A L L O T').move_to(paper).shift(UP*2.75)
        ballot = VGroup(paper, proposals,ballot_title)
        self.play(FadeIn(ballot))
        self.wait(2)
        options = VGroup(Tex(r'Accept'), Tex(r'Abstain'), Tex(r'Reject')).arrange(buff=MED_LARGE_BUFF)\
            .next_to(proposals[0], RIGHT).shift( RIGHT*.5)
        map(lambda o: o.align_to(options[0], UP), options[1:])
        options[1].shift(UP * .05)
        [self.play(Write(o)) for o in options]
        self.wait(2)
        x1 = Tex(r'X').align_to(options[2], LEFT).align_to(proposals[1], DOWN).shift(RIGHT*.5)
        x5 = Tex(r'(X)').align_to(options[1], LEFT).align_to(proposals[2], DOWN).shift(RIGHT*.5)
        x2 = Tex(r'X').align_to(options[0], LEFT).align_to(proposals[3], DOWN).shift(RIGHT*.5)
        x3 = Tex(r'X').align_to(options[0], LEFT).align_to(proposals[4], DOWN).shift(RIGHT*.5)
        x4 = Tex(r'X').align_to(options[1], LEFT).align_to(proposals[5], DOWN).shift(RIGHT*.6)
        self.play(Write(x1))
        self.play(Write(x2))
        self.play(Write(x3))
        self.play(Write(x4))
        self.wait(2)
        cir = Ellipse(7, 1, color=RED).align_to(proposals[2], DOWN).shift(DOWN*.4)
        self.play(ShowCreation(cir))
        self.wait(1)
        self.play(Uncreate(cir))
        self.wait(1)
        self.play(Write(x5))
        self.wait(2)
        cs = VGroup()
        for i in range(1, 5):
            c = paper.copy().set_z_index(-1*i)
            cs.add(c)
            self.play(Transform(c, c.generate_target().shift(UP*.2*i + LEFT*.2*i)))
        self.wait(2)
        self.play(FadeOut(cs), FadeOut(ballot), FadeOut(x1), FadeOut(x2), FadeOut(x3), FadeOut(x4), FadeOut(x5))
        self.play(options.animate.move_to(UP*2))
        acc_score = Tex(r'1').next_to(options[0], DOWN, buff=1.5)
        rej_score = Tex(r'-1').next_to(options[2], DOWN, buff=1.5)
        ab_score = Tex(r'0').next_to(options[1], DOWN, buff=1.5)
        acc_arr = Arrow(options[0].get_bottom(), acc_score.get_top())
        rej_arr = Arrow(options[2].get_bottom(), rej_score.get_top())
        ab_arr = Arrow(options[1].get_bottom(), ab_score.get_top())
        self.play(FadeIn(acc_arr), Write(acc_score))
        self.wait(1)
        self.play(FadeIn(ab_arr), Write(ab_score))
        self.wait(1)
        self.play(FadeIn(rej_arr), Write(rej_score))
        self.wait(2)
        self.play(FadeOut(options), FadeOut(acc_arr), FadeOut(acc_score), FadeOut(ab_arr), FadeOut(ab_score), FadeOut(rej_arr), FadeOut(rej_score))
        self.wait(1)
        flower = FlowerBuddy()
        flower.mouth.smile()
        flower2 = FlowerBuddy('#b547d0', '#ca94f2').next_to(flower, RIGHT)
        flower2.mouth.smile()
        flowers = VGroup(flower, flower2).arrange(DOWN, buff=MED_LARGE_BUFF).shift(LEFT * 5)
        self.play(FadeIn(flowers))
        self.wait(1)
        props2 = proposals[1:].copy().arrange(buff=LARGE_BUFF).move_to(UP * 3 + RIGHT * 2)
        self.play(Write(props2))
        self.wait(1)
        vp1 = Tex(r'1 ETC').next_to(flower, buff=MED_LARGE_BUFF)
        vp2 = Tex(r'3 ETC').next_to(flower2, buff=MED_LARGE_BUFF)
        self.play(FadeIn(vp1))
        self.wait(1)
        self.play(FadeIn(vp2))
        vp1x = MathTex(r'\times', color=RED).next_to(vp1).shift(RIGHT * .2)
        vp2x = MathTex(r'\times', color=RED).next_to(vp2).shift(RIGHT * .2)
        a1 = Tex(r'1').next_to(vp1).align_to(props2[0].get_center(), RIGHT)
        a2 = Tex(r'0').next_to(vp2).align_to(props2[0].get_center(), RIGHT)
        b1 = Tex(r'-1').next_to(vp1).align_to(props2[1].get_center(), RIGHT)
        b2 = Tex(r'1').next_to(vp2).align_to(props2[1].get_center(), RIGHT)
        c1 = Tex(r'1').next_to(vp1).align_to(props2[2].get_center(), RIGHT)
        c2 = Tex(r'1').next_to(vp2).align_to(props2[2].get_center(), RIGHT)
        d1 = Tex(r'-1').next_to(vp1).align_to(props2[3].get_center(), RIGHT)
        d2 = Tex(r'-1').next_to(vp2).align_to(props2[3].get_center(), RIGHT)
        e1 = Tex(r'0').next_to(vp1).align_to(props2[4].get_center(), RIGHT)
        e2 = Tex(r'1').next_to(vp2).align_to(props2[4].get_center(), RIGHT)
        score_line = Line(a2.get_bottom() + LEFT * .3, e2.get_bottom() + RIGHT * .3).shift(DOWN * .4)
        sa = Tex(r'1').next_to(a2, DOWN, buff=1)
        sb = Tex(r'2').next_to(b2, DOWN, buff=1)
        sc = Tex(r'4').next_to(c2, DOWN, buff=1)
        sd = Tex(r'-4').next_to(d2, DOWN, buff=1)
        se = Tex(r'3').next_to(e2, DOWN, buff=1)
        scores = VGroup(sa, sb, sc, sd, se)
        self.play(Write(a1))
        self.wait(1)
        self.play(Write(a2))
        self.wait(1)
        self.play(Write(vp1x))
        self.wait(1)
        self.play(Write(vp2x))
        self.wait(1)
        self.play(ShowCreation(score_line))
        self.wait(1)
        self.play(Write(sa))
        self.wait(1)
        self.play(Write(b1))
        self.wait(1)
        self.play(Write(b2))
        self.wait(1)
        self.play(Write(sb))
        self.wait(1)
        self.play(Write(c1))
        self.wait(1)
        self.play(Write(c2))
        self.play(Write(sc))
        self.play(Write(d1))
        self.play(Write(d2))
        self.play(Write(sd))
        self.play(Write(e1))
        self.play(Write(e2))
        self.play(Write(se))
        self.wait(1)
        self.clear()
        self.wait(1)
        self.play(FadeIn(rules))
        rule1 = Tex(r'1) The score of a proposal is the sum of each voter\'s\\(+1, 0, -1) selection, '
                    r'weighted by their deposit').next_to(rule_func, DOWN, buff=.5)
        rules.add(rule1)
        self.play(Write(rule1))
        self.wait(2)
        self.play(FadeOut(rules))
        prop_and_score = VGroup(*map(lambda g: VGroup(*g), zip(props2, scores))).center()
        for pair in prop_and_score:
            pair[1].next_to(pair[0], DOWN, buff=LARGE_BUFF)
        prop_text = Tex(r'Proposals').next_to(prop_and_score[0][0], LEFT, buff=LARGE_BUFF)
        score_text = Tex(r'Score').next_to(prop_and_score[0][1], LEFT, buff=LARGE_BUFF)
        self.play(FadeIn(prop_and_score), Write(prop_text), Write(score_text))
        prop_xs = list(map(lambda p: p.get_center(), prop_and_score))
        self.wait(2)
        self.play(prop_and_score[0].animate.move_to(prop_xs[3]),
                  prop_and_score[1].animate.move_to(prop_xs[2]),
                  prop_and_score[2].animate.move_to(prop_xs[0]),
                  prop_and_score[3].animate.move_to(prop_xs[4]),
                  prop_and_score[4].animate.move_to(prop_xs[1]),
                  )
        self.wait(2)
        dep_sum = MathTex(r'(1 + 3)').shift(DOWN)
        ten_cent = MathTex(r'.1 \times ').next_to(dep_sum, LEFT)
        threshold = MathTex(r' = .4').next_to(dep_sum, RIGHT)
        eq_group = VGroup(dep_sum, ten_cent, threshold)
        self.play(Write(dep_sum))
        self.wait(1)
        self.play(Write(ten_cent))
        self.wait(1)
        self.play(Write(threshold))
        self.wait(2)
        self.play(FadeOut(prop_and_score[3]))
        prop_and_score.remove(prop_and_score[3])
        self.wait(1)
        self.play(FadeOut(eq_group), FadeOut(prop_and_score), FadeOut(prop_text), FadeOut(score_text))
        self.wait(1)
        self.play(FadeIn(rules))
        rule2 = Tex(r'2) Create a shortlist of acceptable proposals\\that have a score of at least 10\% of the voter '
                    r'deposit').next_to(rule1, DOWN, buff=.5)
        rules.add(rule2)
        self.play(Write(rule2))
        self.wait(2)
        self.play(FadeOut(rules))
        self.wait(1)
        self.play(FadeIn(prop_and_score), Write(prop_text), Write(score_text))
        self.wait(1)
        cost_text = Tex(r'Cost').next_to(score_text, DOWN, buff=LARGE_BUFF).align_to(score_text, RIGHT)
        self.play(Write(cost_text))
        vert_start = prop_and_score.get_corner(UR) + UR*.5
        vert_line = Line(vert_start, vert_start + 6*DOWN)
        self.play(ShowCreation(vert_line))
        prop_fund = Tex(r'Proposal\\Fund')
        fund_amt = Tex(r'10')
        fund_group = VGroup(prop_fund, fund_amt).arrange(DOWN, buff=MED_LARGE_BUFF).next_to(vert_line, buff=.5)
        self.play(FadeIn(fund_group))
        self.wait(2)
        cc = Tex(r'2').next_to(sc, DOWN, buff=1)
        ce = Tex(r'5').next_to(se, DOWN, buff=1)
        cb = Tex(r'4').next_to(sb, DOWN, buff=1)
        ca = Tex(r'2').next_to(sa, DOWN, buff=1)
        costs = VGroup(ca, cb, cc, ce)
        self.play(Write(costs))
        arr = Arrow(cc.get_bottom()+DOWN*2, cc.get_bottom()+DOWN*.4)
        self.wait(2)
        self.play(ShowCreation(arr))
        self.wait(1)
        self.play(Transform(arr, Arrow(ce.get_bottom()+DOWN*2, ce.get_bottom()+DOWN*.4)),
                  prop_and_score[2].animate.set_color('#38b238'),
                  cc.animate.set_color('#38b238'),
                  Transform(fund_amt, Tex(r'8').move_to(fund_amt)))
        self.wait(2)
        self.play(Transform(arr, Arrow(cb.get_bottom()+DOWN*2, cb.get_bottom()+DOWN*.4)),
                  prop_and_score[3].animate.set_color('#38b238'),
                  ce.animate.set_color('#38b238'),
                  Transform(fund_amt, Tex(r'3').move_to(fund_amt)))
        self.wait(2)
        self.play(Transform(arr, Arrow(ca.get_bottom() + DOWN * 2, ca.get_bottom() + DOWN * .4)),
                  prop_and_score[1].animate.set_color(RED),
                  cb.animate.set_color(RED))
        self.wait(2)
        self.play(FadeOut(arr),
                  prop_and_score[0].animate.set_color('#38b238'),
                  ca.animate.set_color('#38b238'),
                  Transform(fund_amt, Tex(r'1').move_to(fund_amt)))
        self.wait(2)
        self.play(FadeOut(VGroup(costs, prop_and_score, vert_line, fund_group, cost_text, prop_text, score_text)))
        self.wait(1)
        self.play(FadeIn(rules))
        rule3 = Tex(r'3) In order, add acceptable proposals as\\winners if there is enough funds for them').next_to(rule2, DOWN, buff=.5).shift(RIGHT*.5)
        rules.add(rule3)
        self.play(Write(rule3))
        self.wait(2)
        self.play(FadeOut(rules))










def flower_voters():
    flower = FlowerBuddy()
    flower.mouth.smile()
    flower2 = FlowerBuddy('#b547d0', '#ca94f2').next_to(flower, LEFT)
    flower2.mouth.smile()
    flower3 = FlowerBuddy('#e49928', '#f0c788').next_to(flower, RIGHT)
    flower3.mouth.smile()
    flower4 = FlowerBuddy('#e49928', '#f0c788').next_to(flower2, LEFT)
    flower4.mouth.smile()
    flower5 = FlowerBuddy().next_to(flower3, RIGHT)
    flower5.mouth.smile()
    return VGroup(flower, flower2, flower3, flower4, flower5)
